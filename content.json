[{"title":"线上排查之--arthas","date":"2020-04-25T08:42:29.000Z","path":"2020/04/25/线上排查之-arthas/","text":"前言作为一名java 的coder，线上问题的排查是始终绕不过去的坎儿，项目大了，或者项目经手的人多了，很难说哪个地方会不会有个隐形的陷阱等着你。很多问题也只有项目的流量上来了才会发现，好了，废话不多说，上干货！ 常用工具toptop这个命令除了运维，一般的coder知道的或许并不多。 这个命令有什么用呢？看效果： 12345678910111213[root@VM_0_15_centos ~]# toptop - 16:50:54 up 18:28, 3 users, load average: 0.00, 0.01, 0.05Tasks: 87 total, 2 running, 85 sleeping, 0 stopped, 0 zombie%Cpu(s): 0.0 us, 0.0 sy, 0.0 ni,100.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 stKiB Mem : 1882056 total, 314288 free, 320940 used, 1246828 buff/cacheKiB Swap: 0 total, 0 free, 0 used. 1377012 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 1 root 20 0 43520 3736 2420 S 0.0 0.2 0:04.16 systemd 2 root 20 0 0 0 0 S 0.0 0.0 0:00.00 kthreadd 4 root 0 -20 0 0 0 S 0.0 0.0 0:00.00 kworker/0:0H 5 root 20 0 0 0 0 S 0.0 0.0 0:04.94 kworker/u2:0 6 root 20 0 0 0 0 S 0.0 0.0 0:00.84 ksoftirqd/0 从实际结果来看，这里分为了两部分： 1、系统信息。包括：运行时间，用户，负载，CPU，内存等 2、线程信息。主要有：线程pid，用户，CPU内存资源使用，所属程序等 jinfo用法：jinfo [pid] 显示java程序运行时，所有的系统参数 jstat动态观察jvm运行状况 比如 jstat -gc pid 监控gc情况 jmap堆内存查看，可以做堆内存转储，形成dump文件。 比如： jmap - histo 4655 | head -20，查找有多少对象产生 jmap -dump:format=b,file=xxx pid ，jmap执行期间会对进程产生很大影响，甚至卡顿，大流量系统是不合适的。 可以使用 MAT / jhat /jvisualvm 进行dump文件分析 这些工具平时开发测试会用到的比较多，但是线上，除了top命令之外，其他可能都没有（openjdk只安装jre是没有的），就算有不能用！！！ arthas正题来了，arthas，阿里开源产品，是个命令行交互工具，本身是一个jar，下载下来就能用（生产环境不一定有权限加进去，允悲！！！） 安装123456789101112# gitee / github[root@VM_0_15_centos arthas]# wget https:/sh/arthas.gitee.io/arthas-boot.jar--2020-04-25 16:25:19-- https://arthas.gitee.io/arthas-boot.jarResolving arthas.gitee.io (arthas.gitee.io)... 212.64.62.174Connecting to arthas.gitee.io (arthas.gitee.io)|212.64.62.174|:443... connected.HTTP request sent, awaiting response... 200 OKLength: 112288 (110K) [application/java-archive]Saving to: ‘arthas-boot.jar’100%[===========================================================&gt;] 112,288 --.-K/s in 0.1s 2020-04-25 16:25:20 (731 KB/s) - ‘arthas-boot.jar’ saved [112288/112288] 开源地址：https://github.com/alibaba/arthas 官方文档：https://alibaba.github.io/arthas 12345# github下载wget https://alibaba.github.io/arthas/arthas-boot.jar# 或者 Gitee 下载wget https://arthas.gitee.io/arthas-boot.jar 安装如此简单。。。 运行方式1：12345678910# 运行方式1，先运行，在选择 Java 进程 PIDjava -jar arthas-boot.jar# 选择进程(输入[]内编号(不是PID)回车)[INFO] arthas-boot version: 3.1.4[INFO] Found existing java process, please choose one and hit RETURN.* [1]: 11616 com.Arthas [2]: 8676 [3]: 16200 org.jetbrains.jps.cmdline.Launcher [4]: 21032 org.jetbrains.idea.maven.server.RemoteMavenServer 方式2：1java -jar arthas-boot.jar [PID] 示例： 1234567891011121314151617181920212223242526272829[root@VM_0_15_centos arthas]# java -jar arthas-boot.jar [INFO] arthas-boot version: 3.2.0[INFO] Can not find java process. Try to pass &lt;pid&gt; in command line.Please select an available pid.[root@VM_0_15_centos arthas]# java -jar arthas-boot.jar [INFO] arthas-boot version: 3.2.0[INFO] Found existing java process, please choose one and input the serial number of the process, eg : 1. Then hit ENTER.* [1]: 19380 TestOOM1[INFO] Start download arthas from remote server: https://maven.aliyun.com/repository/public/com/taobao/arthas/arthas-packaging/3.2.0/arthas-packaging-3.2.0-bin.zip[INFO] Download arthas success.[INFO] arthas home: /root/.arthas/lib/3.2.0/arthas[INFO] Try to attach process 19380[INFO] Attach process 19380 success.[INFO] arthas-client connect 127.0.0.1 3658 ,---. ,------. ,--------.,--. ,--. ,---. ,---. / O \\ | .--. ''--. .--'| '--' | / O \\ ' .-' | .-. || '--'.' | | | .--. || .-. |`. `-. | | | || |\\ \\ | | | | | || | | |.-' | `--' `--'`--' '--' `--' `--' `--'`--' `--'`-----' wiki https://alibaba.github.io/arthas tutorials https://alibaba.github.io/arthas/arthas-tutorials version 3.2.0 pid 19380 time 2020-04-25 16:31:55 [arthas@19380]$ session (b2791cc9-82d4-4431-a072-4fd991d0c791) is closed because session is inactive for 30 min(s). 上面是我的操作过程。 常用操作每个操作都 -h查看帮助信息 1234# 查看运行的 java 进程信息$ jps -mlvV # 筛选 java 进程信息$ jps -mlvV | grep [xxx] 贴一下其他的常用命令 命令 介绍 dashboard 当前系统的实时数据面板 thread 查看当前 JVM 的线程堆栈信息 watch 方法执行数据观测 trace 方法内部调用路径，并输出方法路径上的每个节点上耗时 stack 输出当前方法被调用的调用路径 tt 方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测 monitor 方法执行监控 jvm 查看当前 JVM 信息 vmoption 查看，更新 JVM 诊断相关的参数 sc 查看 JVM 已加载的类信息 sm 查看已加载类的方法信息 jad 反编译指定已加载类的源码 classloader 查看 classloader 的继承树，urls，类加载信息 heapdump 类似 jmap 命令的 heap dump 功能 退出shutdown 命令，这个就不多说了 也用可以通过 arthas能解决什么 全局监控，dashboard （内存、cpu、GC、系统参数等） Thread监控 线程信息、数量、执行状态等 线程池运行状况 死锁检测 thread -b, 直接定位死锁的位置， jstack pid 来dump输出堆栈信息， 123456789101112131415\"DubboServerHandler-192.168.10.26:12350-thread-200\" #240 daemon prio=5 os_prio=0 tid=0x00007ffa7c141800 nid=0x6c89 waiting on condition [0x00007ffa17c7c000] java.lang.Thread.State: WAITING (parking) at sun.misc.Unsafe.park(Native Method) - parking to wait for &lt;0x00000000e0d24020&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject) at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175) at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039) at org.apache.commons.pool2.impl.LinkedBlockingDeque.takeFirst(LinkedBlockingDeque.java:590) at org.apache.commons.pool2.impl.GenericObjectPool.borrowObject(GenericObjectPool.java:441) at org.apache.commons.pool2.impl.GenericObjectPool.borrowObject(GenericObjectPool.java:362) at redis.clients.util.Pool.getResource(Pool.java:49) at redis.clients.jedis.JedisPool.getResource(JedisPool.java:226) at (RedisHelper.java:322) at (RedisHelper.java:106) at BlockResourceManager.java:54) - locked &lt;0x00000000e0ec22d0&gt; 可以看到最后一条线程locked &lt;0x00000000e0ec22d0&gt;，说明它持有着这个锁，而其他线程状态都是waiting to lock &lt;0x00000000e0ec22d0&gt;。看来就是这条线程导致了其他线程被阻塞。 反编译 1234# 反编译只显示源码jad --source-only com.Arthas# 反编译某个类的某个方法jad --source-only com.Arthas mysql trace 跟踪 跟踪执行过程，统计方法耗时等 monitor命令监控统计方法执行情况 watch 查看输入输出参数以及异常信息 总结最常用命令，dashboard、thread，合理运用工具，享受健康生活！！！","categories":[],"tags":[{"name":"线上运维","slug":"线上运维","permalink":"https://ccmuyu.github.io/tags/线上运维/"},{"name":"JVM监控","slug":"JVM监控","permalink":"https://ccmuyu.github.io/tags/JVM监控/"}]},{"title":"apollo架构","date":"2020-03-22T08:58:07.000Z","path":"2020/03/22/apollo架构/","text":"apollo简介前端时间公司项目需要，由传统的静态打包配置切换到了动态配置中心，在此总结一些使用心得。 github项目地址： apollo 理论还是要了解的，有助于快速理解整体架构。这里主要从架构和客户端使用原理入手 架构原理引用作者的架构图： 四个核心模块及其主要功能 ConfigService 提供配置获取接口 提供配置推送接口 服务于Apollo客户端 AdminService 提供配置管理接口 提供配置修改发布接口 服务于管理界面Portal Client 为应用获取配置，支持实时更新 通过MetaServer获取ConfigService的服务列表 使用客户端软负载SLB方式调用ConfigService Portal 配置管理界面 通过MetaServer获取AdminService的服务列表 使用客户端软负载SLB方式调用AdminService 三个辅助服务发现模块 Eureka 用于服务发现和注册 Config/AdminService注册实例并定期报心跳 和ConfigService住在一起部署 MetaServer Portal通过域名访问MetaServer获取AdminService的地址列表 Client通过域名访问MetaServer获取ConfigService的地址列表 相当于一个Eureka Proxy 逻辑角色，和ConfigService住在一起部署 NginxLB 和域名系统配合，协助Portal访问MetaServer获取AdminService地址列表 和域名系统配合，协助Client访问MetaServer获取ConfigService地址列表 和域名系统配合，协助用户访问Portal进行配置管理 简易架构图： 要点： ConfigService是一个独立的微服务，服务于Client进行配置获取。 Client和ConfigService保持长连接，通过一种拖拉结合(push &amp; pull)的模式，实现配置实时更新的同时，保证配置更新不丢失。 AdminService是一个独立的微服务，服务于Portal进行配置管理。Portal通过调用AdminService进行配置管理和发布。 ConfigService和AdminService共享ConfigDB，ConfigDB中存放项目在某个环境的配置信息。ConfigService/AdminService/ConfigDB三者在每个环境(DEV/FAT/UAT/PRO)中都要部署一份。 Protal有一个独立的PortalDB，存放用户权限、项目和配置的元数据信息。Protal只需部署一份，它可以管理多套环境。 V5 版本架构图示： 源码解析客户端 spring接入：$$http\\://www.ctrip.com/schema/apollo=com.ctrip.framework.apollo.spring.config.NamespaceHandler$$spring boot接入：$$org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\com.ctrip.framework.apollo.spring.boot.ApolloAutoConfigurationorg.springframework.context.ApplicationContextInitializer=\\com.ctrip.framework.apollo.spring.boot.ApolloApplicationContextInitializerorg.springframework.boot.env.EnvironmentPostProcessor=\\com.ctrip.framework.apollo.spring.boot.ApolloApplicationContextInitializer$$ 以spring使用为例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class NamespaceHandler extends NamespaceHandlerSupport &#123; private static final Splitter NAMESPACE_SPLITTER = Splitter.on(\",\").omitEmptyStrings().trimResults(); @Override public void init() &#123; //解析器注册，支持apollo的xml标签 registerBeanDefinitionParser(\"config\", new BeanParser()); &#125; //xml解析器 static class BeanParser extends AbstractSingleBeanDefinitionParser &#123; @Override protected Class&lt;?&gt; getBeanClass(Element element) &#123; //属性 return ConfigPropertySourcesProcessor.class; &#125; @Override protected boolean shouldGenerateId() &#123; return true; &#125; @Override protected void doParse(Element element, BeanDefinitionBuilder builder) &#123; String namespaces = element.getAttribute(\"namespaces\"); //default to application if (Strings.isNullOrEmpty(namespaces)) &#123; //所以默认会处理application配置 namespaces = ConfigConsts.NAMESPACE_APPLICATION; &#125; //优先级 int order = Ordered.LOWEST_PRECEDENCE; String orderAttribute = element.getAttribute(\"order\"); if (!Strings.isNullOrEmpty(orderAttribute)) &#123; try &#123; order = Integer.parseInt(orderAttribute); &#125; catch (Throwable ex) &#123; throw new IllegalArgumentException( String.format(\"Invalid order: %s for namespaces: %s\", orderAttribute, namespaces)); &#125; &#125; PropertySourcesProcessor.addNamespaces(NAMESPACE_SPLITTER.splitToList(namespaces), order); &#125; &#125;&#125; NamespaceHandlerSupport 是spring xml配置的解析抽象类，解析结果为BeanDefinition，这是spring bean实例的描述类，描述信息包含类的构造器，成员变量等 ConfigPropertySourcesProcessor ：将加载的BeanDefinition 处理，apollo拦截了spring bean的注册过程，所以在获取到apollo配置的属性值后，最终完成向容器注册的过程。 以下是初始化启动时的的配置过程 123456789101112// BeanRegistrationUtil &#125; BeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition(beanClass).getBeanDefinition(); if (extraPropertyValues != null) &#123; for (Map.Entry&lt;String, Object&gt; entry : extraPropertyValues.entrySet()) &#123; beanDefinition.getPropertyValues().add(entry.getKey(), entry.getValue()); &#125; &#125; registry.registerBeanDefinition(beanName, beanDefinition); 动态配置中心最重要是就是支持配置信息的实时变化，apollo在启动时通过spi，注入以下实例 1com.ctrip.framework.apollo.internals.DefaultInjector 123456789101112131415161718192021222324252627282930public class DefaultInjector implements Injector &#123; private com.google.inject.Injector m_injector; public DefaultInjector() &#123; try &#123; m_injector = Guice.createInjector(new ApolloModule()); &#125; catch (Throwable ex) &#123; ApolloConfigException exception = new ApolloConfigException(\"Unable to initialize Guice Injector!\", ex); Tracer.logError(exception); throw exception; &#125; &#125; // 省略。。。 private static class ApolloModule extends AbstractModule &#123; @Override protected void configure() &#123; bind(ConfigManager.class).to(DefaultConfigManager.class).in(Singleton.class); bind(ConfigFactoryManager.class).to(DefaultConfigFactoryManager.class).in(Singleton.class); bind(ConfigRegistry.class).to(DefaultConfigRegistry.class).in(Singleton.class); bind(ConfigFactory.class).to(DefaultConfigFactory.class).in(Singleton.class); bind(ConfigUtil.class).in(Singleton.class); bind(HttpUtil.class).in(Singleton.class); bind(ConfigServiceLocator.class).in(Singleton.class); //这个长轮询服务就是监听远程仓库的配置信息变化 bind(RemoteConfigLongPollService.class).in(Singleton.class); &#125; &#125;&#125; 长轮询服务源码实现如下 1234567891011121314151617181920212223242526272829303132333435363738private void doLongPollingRefresh(String appId, String cluster, String dataCenter) &#123; final Random random = new Random(); ServiceDTO lastServiceDto = null; while (!m_longPollingStopped.get() &amp;&amp; !Thread.currentThread().isInterrupted()) &#123; if (!m_longPollRateLimiter.tryAcquire(5, TimeUnit.SECONDS)) &#123; //wait at most 5 seconds try &#123; TimeUnit.SECONDS.sleep(5); &#125; catch (InterruptedException e) &#123; &#125; &#125; //省略。。。 HttpRequest request = new HttpRequest(url); request.setReadTimeout(LONG_POLLING_READ_TIMEOUT); transaction.addData(\"Url\", url); final HttpResponse&lt;List&lt;ApolloConfigNotification&gt;&gt; response = m_httpUtil.doGet(request, m_responseType); logger.debug(\"Long polling response: &#123;&#125;, url: &#123;&#125;\", response.getStatusCode(), url); if (response.getStatusCode() == 200 &amp;&amp; response.getBody() != null) &#123; //更新本地bean的spring value updateNotifications(response.getBody()); updateRemoteNotifications(response.getBody()); transaction.addData(\"Result\", response.getBody().toString()); notify(lastServiceDto, response.getBody()); &#125; //try to load balance if (response.getStatusCode() == 304 &amp;&amp; random.nextBoolean()) &#123; lastServiceDto = null; &#125; m_longPollFailSchedulePolicyInSecond.success(); //省略。。。。 &#125;&#125; 当长轮询收到配置变更之后，触发本地与远程的同步任务 com.ctrip.framework.apollo.internals.RemoteConfigRepository#sync 123456789101112131415161718192021222324252627protected synchronized void sync() &#123; Transaction transaction = Tracer.newTransaction(\"Apollo.ConfigService\", \"syncRemoteConfig\"); try &#123; ApolloConfig previous = m_configCache.get(); ApolloConfig current = loadApolloConfig(); //虽然304不会更新通知，但是每次更新后会缓存在本地，这里仅作安全验证 //reference equals means HTTP 304 if (previous != current) &#123; logger.debug(\"Remote Config refreshed!\"); m_configCache.set(current); this.fireRepositoryChange(m_namespace, this.getConfig()); &#125; if (current != null) &#123; Tracer.logEvent(String.format(\"Apollo.Client.Configs.%s\", current.getNamespaceName()), current.getReleaseKey()); &#125; transaction.setStatus(Transaction.SUCCESS); &#125; catch (Throwable ex) &#123; transaction.setStatus(ex); throw ex; &#125; finally &#123; transaction.complete(); &#125;&#125; 3种spring value 变更事件 1234567891011121314151617181920//1public class ConfigFileChangeEvent &#123; private final String namespace; private final String oldValue; private final String newValue; private final PropertyChangeType changeType;&#125;//2public class ConfigChangeEvent &#123; private final String m_namespace; private final Map&lt;String, ConfigChange&gt; m_changes;&#125;//3public class ConfigChange &#123; private final String namespace; private final String propertyName; private String oldValue; private String newValue; private PropertyChangeType changeType;&#125; 处理spring value值变更 com.ctrip.framework.apollo.spring.property.AutoUpdateConfigChangeListener 1234567891011121314151617181920212223242526272829303132333435363738394041424344public void onChange(ConfigChangeEvent changeEvent) &#123; Set&lt;String&gt; keys = changeEvent.changedKeys(); if (CollectionUtils.isEmpty(keys)) &#123; return; &#125; for (String key : keys) &#123; //这里的对于spring容器的bean处理非常精髓，每个IOC容器作为map的一个value，同时每一个key对应的所有bean实例value引用 // 1. check whether the changed key is relevant Collection&lt;SpringValue&gt; targetValues = springValueRegistry.get(beanFactory, key); if (targetValues == null || targetValues.isEmpty()) &#123; continue; &#125; // 2. check whether the value is really changed or not (since spring property sources have hierarchies) if (!shouldTriggerAutoUpdate(changeEvent, key)) &#123; continue; &#125; // 3. update the value for (SpringValue val : targetValues) &#123; updateSpringValue(val); &#125; &#125;&#125;//更新字段和方法public void update(Object newVal) throws IllegalAccessException, InvocationTargetException &#123; if (isField()) &#123; injectField(newVal); &#125; else &#123; injectMethod(newVal); &#125; &#125; private void injectField(Object newVal) throws IllegalAccessException &#123; Object bean = beanRef.get(); if (bean == null) &#123; return; &#125; boolean accessible = field.isAccessible(); field.setAccessible(true); field.set(bean, newVal); field.setAccessible(accessible); &#125; 至此对于apollo客户端的实现基本结束了，上面列出的代码是配置变更的核心实现，可以看出确实逻辑相对简单，实现也很巧妙，最适合新手入门的中间件我是认可的。 使用指南：apollo架构相比其他中间件而言，没有使用太多高深技巧，正如官网上所说的这可能是最适合初学者通过源码来学习的分布式中间件产品 客户端参见github官网wiki 客户端wiki","categories":[],"tags":[{"name":"apollo","slug":"apollo","permalink":"https://ccmuyu.github.io/tags/apollo/"},{"name":"动态配置中心","slug":"动态配置中心","permalink":"https://ccmuyu.github.io/tags/动态配置中心/"}]},{"title":"JDK源码精读(一)","date":"2019-05-27T13:42:18.000Z","path":"2019/05/27/JDK源码精读系列（一）/","text":"JDK精读系列（一）最近有点焦躁，可能是大环境所影响，对未来有点焦虑，不想在未来的浪潮里被淘汰。 从毕业到现在工作了几年，虽然接触的知识及其广泛，变成语言从静态语言java到jvm上的groovy、Kotlin，甚至golang，到流行的动态语言python、javascript都有一定涉猎。从前端vue到数据库mysql、redis等有也用的比较多。可是进来却感觉一阵迷茫，不知道自己的核心竞争力是什么。痛定思痛，从项目中用的最多，却最不起眼的jdk开始从头再来。 首先需要认识下jdk中的3个包rt.jar、tools.jar和dt.jar dt.jar和tools.jar位于：{Java_Home}/lib/下，而rt.jar位于：{Java_Home}/jre/lib/下,其中：dt.jar是关于运行环境的类库; tools.jar是工具类库,编译和运行需要的都是toos.jar里面的类分别是sun.tools.java.; sun.tols.javac.; 在Classpath设置这几个变量，是为了方便在程序中 import；Web系统都用到tool.jar。 rt.jar rt.jar 默认就在Root Classloader的加载路径里面的，而在Claspath配置该变量是不需要的；同时jre/lib目录下的 其他jar:jce.jar、jsse.jar、charsets.jar、resources.jar都在Root Classloader中 tools.jar tools.jar 是系统用来编译一个类的时候用到的，即执行javac的时候用到 javac XXX.java 实际上就是运行 java -classpath=%JAVA_HOME%\\lib\\tools.jar xx.xxx.Main XXX.java javac就是对上面命令的封装 所以tools.jar 也不用加到classpath里面 dt.jar dt.jar是关于运行环境的类库,主要是swing的包 在用到swing时最好加上。 也即是： rt.jar：Java基础类库，也就是Java doc里面看到的所有的类的class文件。 tools.jar：是系统用来编译一个类的时候用到的，即执行javac的时候用到。 dt.jar：dt.jar是关于运行环境的类库，主要是swing包。 2、rt.jar从上面几个包的介绍来看，跟我们平常开发关系最紧密的就是rd.jar了，下图是在idea下的rt.jar com包没什么可说的，是oracle和sun公司的两个子包，openJDK是不包含着部分的，跟我们这些coder来说，息息相关的就是java包和javax包了，由于javax的使用不是很常见，本文只讨论java包。 3、java包解析以上图为切入点，applet和awt就不必说了，这是做桌面小程序所用到的，现在java的优势在于服务端的应用，我们从beans包开始。 beans包： 从java doc里的描述来看， BeanContext充当javabean的逻辑层次容器。BeanContext提供与 bean 上下文有关的类和接口。 详细描述可以参考java api：http://jszx-jxpt.cuit.edu.cn/JavaAPI/java/beans/beancontext/package-use.html/ 这个包下所有的类和接口基本都是围绕javabean和反射的。 举个简单的例子： 如果我们想获取一个类的私有变量，肯定都知道用反射，也通常都会这样： 1234567Object o = new InternetAddress(); //第一种 Class&lt;?&gt; aClass = o.getClass(); Field[] fields = aClass.getDeclaredFields(); for (Field field : fields) &#123; field.setAccessible(true); &#125; 但是这样直接修改访问权限就违背了java封装的初衷了，也有一定的安全隐患。这个时候换下面这种方式看起来就舒服多了。并且在一定程度上解决了安全问题，很多框架也渐渐在采用这种方式来进行反射的调用。 12345678BeanInfo beanInfo = Introspector.getBeanInfo(InternetAddress.class); PropertyDescriptor[] descriptors = beanInfo.getPropertyDescriptors(); for (PropertyDescriptor descriptor : descriptors) &#123; Method readMethod = descriptor.getReadMethod(); Method writeMethod = descriptor.getWriteMethod(); Object value = readMethod.invoke(o); writeMethod.invoke(o, 1); &#125; IO包io是各个编程语言的核心之一，很多程序的吞吐和性能瓶颈就在于io这块，java的io体系更是及其繁杂。简单来说，可以分为输入I/输出O两部分，从两个基类InputStream、OutputStream。基于字符的Writer和Reader，基于磁盘的File，基于网络的Socket（不在java.io包下）都要基于上面两个基类。 引用网上的一张图： https://blog.csdn.net/zhangerqing/article/details/8466532/ 上一些代码来辅助使用说明： 附上最常用的IO操作 12345678910public static String read(String filename) throws Exception &#123; BufferedReader br = new BufferedReader(new FileReader(filename)); String s; StringBuffer sb = new StringBuffer(); while ((s = br.readLine()) != null) &#123; sb.append(s + &quot;\\n&quot;); &#125; br.close(); return sb.toString(); &#125; 好了，今天就到这里。明天继续！","categories":[],"tags":[{"name":"JDK源码精读","slug":"JDK源码精读","permalink":"https://ccmuyu.github.io/tags/JDK源码精读/"}]},{"title":"JDK源码精读(二)","date":"2019-05-27T13:42:18.000Z","path":"2019/05/27/JDK源码精读系列（二）/","text":"JDK源码精读系列（二）","categories":[],"tags":[{"name":"JDK源码精读","slug":"JDK源码精读","permalink":"https://ccmuyu.github.io/tags/JDK源码精读/"}]},{"title":"dubbo源码精读","date":"2019-05-27T13:42:18.000Z","path":"2019/05/27/dubbo源码精读（一）/","text":"dubbo源码精读（一）dubbo作为java rpc框架中的一员，重要性就不多说了，每次出去跟人交流也总提到这个，虽然项目中一直在用，可却从来没完整的、系统的学习过dubbo。今天开始迈出dubbo第一步： 关于dubbo的额接本概念解释这里不做过多介绍，可以参考这篇博文,从架构层面理解dubbo: dubbo的底层原理：https://blog.csdn.net/qq_33101675/article/details/78701305 下图为我在项目中的dubbo2.5.3jar包目录结构 hession 包dubbo支持多种序列化方式，有dubbo、hessian、java、json、nativejava，（具体下文会介绍），hessian是dubbo默认的序列化方式。 dubbo这里是直接使用hessian的一个开源实现放到了com.alibaba包下，也即是上图中的con.caucho.hessian包。这个包中主要是io包，hessian对于数据的序列化和反序列化所有实现全部在这里。其余两个包是RSA加密相关和工具类。有兴趣可以参考下，个人认为没有必要深究 不出意外。序列化的顶级接口： 1234567891011package com.alibaba.com.caucho.hessian.io;import java.io.IOException;/** * Serializing an object. */public interface Serializer &#123; public void writeObject(Object obj, AbstractHessianOutput out) throws IOException;&#125; hessian序列化的具体实现代码在com.alibaba.com.caucho.hessian.io.Hessian2Output中。这里不在展示源码和贴图，简单来说就是将（byte[]） 数组转换为二进制数据，并写入流中。反序列化则刚好相反，将二进制数据转化字符编码，进而转化为java的数据类型。 反序列化的顶级接口： 12345678910111213141516171819202122232425package com.alibaba.com.caucho.hessian.io;import java.io.IOException;/** * Deserializing an object. */public interface Deserializer &#123; public Class getType(); public Object readObject(AbstractHessianInput in) throws IOException; public Object readList(AbstractHessianInput in, int length) throws IOException; public Object readLengthList(AbstractHessianInput in, int length) throws IOException; public Object readMap(AbstractHessianInput in) throws IOException; public Object readObject(AbstractHessianInput in, String []fieldNames) throws IOException;&#125; dubbo包到这里，才是真正dubbo的核心实现。从前面的图中可以看到，dubbo的实现主要包含这些内容： cache：本地缓存，缓存服务列表 common：资源工具类和注解等，包括io、日志、拓展类、JSON、线程池、各种工具类 config：dubbo配置的解析器，包括元注解、xml配置解析器及解析对象的定义，以下代码为xml解析的入口。 123456789101112131415161718192021222324252627282930313233343536373839404142package com.alibaba.dubbo.config.spring.schema;import org.springframework.beans.factory.xml.NamespaceHandlerSupport;import com.alibaba.dubbo.common.Version;import com.alibaba.dubbo.config.ApplicationConfig;import com.alibaba.dubbo.config.ConsumerConfig;import com.alibaba.dubbo.config.ModuleConfig;import com.alibaba.dubbo.config.MonitorConfig;import com.alibaba.dubbo.config.ProtocolConfig;import com.alibaba.dubbo.config.ProviderConfig;import com.alibaba.dubbo.config.RegistryConfig;import com.alibaba.dubbo.config.spring.AnnotationBean;import com.alibaba.dubbo.config.spring.ReferenceBean;import com.alibaba.dubbo.config.spring.ServiceBean;/** * DubboNamespaceHandler * * @author william.liangf * @export */public class DubboNamespaceHandler extends NamespaceHandlerSupport &#123; static &#123; Version.checkDuplicate(DubboNamespaceHandler.class); &#125; public void init() &#123; registerBeanDefinitionParser(&quot;application&quot;, new DubboBeanDefinitionParser(ApplicationConfig.class, true)); registerBeanDefinitionParser(&quot;module&quot;, new DubboBeanDefinitionParser(ModuleConfig.class, true)); registerBeanDefinitionParser(&quot;registry&quot;, new DubboBeanDefinitionParser(RegistryConfig.class, true)); registerBeanDefinitionParser(&quot;monitor&quot;, new DubboBeanDefinitionParser(MonitorConfig.class, true)); registerBeanDefinitionParser(&quot;provider&quot;, new DubboBeanDefinitionParser(ProviderConfig.class, true)); registerBeanDefinitionParser(&quot;consumer&quot;, new DubboBeanDefinitionParser(ConsumerConfig.class, true)); registerBeanDefinitionParser(&quot;protocol&quot;, new DubboBeanDefinitionParser(ProtocolConfig.class, true)); registerBeanDefinitionParser(&quot;service&quot;, new DubboBeanDefinitionParser(ServiceBean.class, true)); registerBeanDefinitionParser(&quot;reference&quot;, new DubboBeanDefinitionParser(ReferenceBean.class, false)); registerBeanDefinitionParser(&quot;annotation&quot;, new DubboBeanDefinitionParser(AnnotationBean.class, true)); &#125;&#125; container：对spring、log4j、logback、servlet等的支持 monitor：对provider、consumer的监控和数据统计，核心的实现在类DubboMonitor中 registry：服务的注册与发现，其中服务支持redis和zookeeper两种，如果有需要也可以自己实现注册中心，实现registryService和注册工厂即可。zk的注册实现在ZookeeperRegistry中。这也是项目中最常用的注册中心 remoting：主要提供了一些远程通信的实现，包括http、p2p、telnet。还集成了zookeeper的客户端 rpc：这是dubbo作为一个服务调用框架的核心功能。包含了对集群的处理、监听、通信协议、代理的实现、过滤器、rpc容器与调用等 今天就先到这里，后续对rpc继续写个专题。","categories":[],"tags":[]},{"title":"Java中的设计模式实践","date":"2019-05-27T13:42:18.000Z","path":"2019/05/27/java中最常用的几种设计模式/","text":"Java中最常用的几种设计模式1、单例模式常见写法：懒汉式、饿汉式、静态代码块、静态内部类、枚举等。推荐采用后3种。 12345678910111213141516//懒汉式public class Singleton &#123; /* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */ private static Singleton instance = null; /* 私有构造方法，防止被实例化 */ private Singleton() &#123;&#125; /* 1:懒汉式，静态工程方法，创建实例 */ public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 1234567891011121314151617181920212223//静态内部类，推荐使用public class SingletonInner &#123; /** * 内部类实现单例模式 * 延迟加载，减少内存开销 */ private static class SingletonHolder &#123; private static SingletonInner instance = new SingletonInner(); &#125; /** * 私有的构造函数 */ private SingletonInner() &#123;&#125; public static SingletonInner getInstance() &#123; return SingletonHolder.instance; &#125; protected void method() &#123; System.out.println(&quot;SingletonInner&quot;); &#125; &#125; 其他模式不再赘述。 2、工厂模式 简单工厂模式 Simple Factory（静态工厂）：不利于长生系列产品 工厂方式模式 Facatory Method : 多形性工厂 抽象工厂模式 Abstract Factory：又称为工具箱，产生产品族，但不利于产生新的产品 静态工厂12345678public class Factory&#123; //getClass 产生Sample 一般可使用动态类装载装入类。 public static Sample creator(int which)&#123; if (which==1) return new SampleA(); else if (which==2) return new SampleB(); &#125;&#125; 目前比较流行的规范是把静态工厂方法命名为valueOf或者getInstance 12Integer a=Integer.valueOf(100); //返回取值为100的Integer对象Calendar cal=Calendar.getInstance(Locale.CHINA); //返回符合中国标准的日历 工厂方法模式工厂方法模式是简单工厂模式的进一步抽象化和推广，工厂方法模式里不再只由一个工厂类决定那一个产品类应当被实例化,这个决定被交给抽象工厂的子类去做。来看下它的组成： 抽象工厂角色： 这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在java中它由抽象类或者接口来实现。 具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象 抽象产品角色：它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现。 具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现。 工厂方法模式使用继承自抽象工厂角色的多个子类来代替简单工厂模式中的“上帝类”。正如上面所说，这样便分担了对象承受的压力；而且这样使得结构变得灵活 起来——当有新的产品（即暴发户的汽车）产生时，只要按照抽象产品角色、抽象工厂角色提供的合同来生成，那么就可以被客户使用，而不必去修改任何已有的代 码。可以看出工厂角色的结构也是符合开闭原则的！ 12345678910111213141516171819202122232425262728293031323334353637383940414243//抽象产品角色public interface Moveable &#123; void run();&#125;//具体产品角色public class Plane implements Moveable &#123; @Override public void run() &#123; System.out.println(&quot;plane....&quot;); &#125;&#125;//具体产品角色public class Broom implements Moveable &#123; @Override public void run() &#123; System.out.println(&quot;broom.....&quot;); &#125;&#125;//抽象工厂public abstract class VehicleFactory &#123; abstract Moveable create();&#125;//具体工厂public class PlaneFactory extends VehicleFactory&#123; public Moveable create() &#123; return new Plane(); &#125;&#125;//具体工厂public class BroomFactory extends VehicleFactory&#123; public Moveable create() &#123; return new Broom(); &#125;&#125;//测试类public class Test &#123; public static void main(String[] args) &#123; VehicleFactory factory = new BroomFactory(); Moveable m = factory.create(); m.run(); &#125;&#125; 简单工厂和工厂方法模式的比较 工厂方法模式和简单工厂模式在定义上的不同是很明显的。工厂方法模式的核心是一个抽象工厂类,而不像简单工厂模式, 把核心放在一个实类上。工厂方法模式可以允许很多实的工厂类从抽象工厂类继承下来, 从而可以在实际上成为多个简单工厂模式的综合,从而推广了简单工厂模式。反过来讲,简单工厂模式是由工厂方法模式退化而来。设想如果我们非常确定一个系统只需要一个实的工厂类, 那么就不妨把抽象工厂类合并到实的工厂类中去。而这样一来,我们就退化到简单工厂模式了。 抽象工厂模式 123456789101112131415161718192021222324252627282930313233//抽象工厂类public abstract class AbstractFactory &#123; public abstract Vehicle createVehicle(); public abstract Weapon createWeapon(); public abstract Food createFood();&#125;//具体工厂类，其中Food,Vehicle，Weapon是抽象类，public class DefaultFactory extends AbstractFactory&#123; @Override public Food createFood() &#123; return new Apple(); &#125; @Override public Vehicle createVehicle() &#123; return new Car(); &#125; @Override public Weapon createWeapon() &#123; return new AK47(); &#125;&#125;//测试类public class Test &#123; public static void main(String[] args) &#123; AbstractFactory f = new DefaultFactory(); Vehicle v = f.createVehicle(); v.run(); Weapon w = f.createWeapon(); w.shoot(); Food a = f.createFood(); a.printName(); &#125;&#125; 在抽象工厂模式中，抽象产品 (AbstractProduct) 可能是一个或多个，从而构成一个或多个产品族(Product Family)。 在只有一个产品族的情况下，抽象工厂模式实际上退化到工厂方法模式。 总结 简单工厂模式是由一个具体的类去创建其他类的实例，父类是相同的，父类是具体的。 工厂方法模式是有一个抽象的父类定义公共接口，子类负责生成具体的对象，这样做的目的是将类的实例化操作延迟到子类中完成。 抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无须指定他们具体的类。它针对的是有多个产品的等级结构。而工厂方法模式针对的是一个产品的等级结构。 3、建造者模式（builder）基本概念：是一种对象构建的设计模式，它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。 Builder模式是一步一步创建一个复杂的对象，它允许用户可以只通过指定复杂对象的类型和内容就可以构建它们。用户不知道内部的具体构建细节。Builder模式是非常类似抽象工厂模式，细微的区别大概只有在反复使用中才能体会到。 swagger中一个对builder的经典运用： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class ModelBuilder &#123; private String id; private String name; private String qualifiedType; private String description; private String baseModel; private String discriminator; private ResolvedType modelType; private String example; private Map&lt;String, ModelProperty&gt; properties = Maps.newHashMap(); private List&lt;String&gt; subTypes = Lists.newArrayList(); public ModelBuilder() &#123; &#125; public ModelBuilder id(String id) &#123; this.id = (String)BuilderDefaults.defaultIfAbsent(id, this.id); return this; &#125; public ModelBuilder name(String name) &#123; this.name = (String)BuilderDefaults.defaultIfAbsent(name, this.name); return this; &#125; public ModelBuilder qualifiedType(String qualifiedType) &#123; this.qualifiedType = (String)BuilderDefaults.defaultIfAbsent(qualifiedType, this.qualifiedType); return this; &#125; public ModelBuilder properties(Map&lt;String, ModelProperty&gt; properties) &#123; this.properties.putAll(BuilderDefaults.nullToEmptyMap(properties)); return this; &#125; public ModelBuilder description(String description) &#123; this.description = (String)BuilderDefaults.defaultIfAbsent(description, this.description); return this; &#125; public ModelBuilder baseModel(String baseModel) &#123; this.baseModel = (String)BuilderDefaults.defaultIfAbsent(baseModel, this.baseModel); return this; &#125; public ModelBuilder discriminator(String discriminator) &#123; this.discriminator = (String)BuilderDefaults.defaultIfAbsent(discriminator, this.discriminator); return this; &#125; public ModelBuilder subTypes(List&lt;String&gt; subTypes) &#123; if (subTypes != null) &#123; this.subTypes.addAll(subTypes); &#125; return this; &#125; public ModelBuilder example(String example) &#123; this.example = (String)BuilderDefaults.defaultIfAbsent(example, this.example); return this; &#125; public ModelBuilder type(ResolvedType modelType) &#123; this.modelType = (ResolvedType)BuilderDefaults.defaultIfAbsent(modelType, this.modelType); return this; &#125; public Model build() &#123; return new Model(this.id, this.name, this.modelType, this.qualifiedType, this.properties, this.description, this.baseModel, this.discriminator, this.subTypes, this.example); &#125;&#125; 4、观察者模式观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。观察者模式又叫发布-订阅(Publish/Subscribe)模式。 Subject类：它把所有对观察者对象的引用保存在一个聚集里，每个主题都可以有任何数量的观察着。抽象主题提供一个接口，可以增加和删除观察着对象。 Observer类：抽象观察者，为所有的具体观察者定义一个接口，在得到主题的通知时更新自己。 ConcreteSubject类：具体主题，将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。 ConcreteObserver类：具体观察者，实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。 观察者模式何时适用？ 当一个抽象模型有两个方面，其中一个方面依赖于另一方面。将这二者封装在独立的对象中可以使他们各自独立地改变和复用。 当对一个对象的改变需要同时改变其它对象，而不知道具体由多少对象有待改变。 当一个对象必须通知其他对象，而它又不能假定其他对象是谁，换言之，你不希望这些对象是紧密耦合的。让耦合的双方都依赖于抽象，而不是依赖于具体。 具体的代码就不贴了，spring中的ApplicationListener 和ApplicationEvent 就是典型的观察者模式的应用。 123456789public interface ApplicationListener&lt;E extends ApplicationEvent&gt; extends EventListener &#123; /** * Handle an application event. * @param event the event to respond to */ void onApplicationEvent(E event);&#125; 5、适配器模式（Adapter）适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。 适配器模式的结构适配器模式有类的适配器模式和对象的适配器模式两种不同的形式。 类适配器： 12345678910public interface Target &#123; /** * 这是源类Adaptee也有的方法 */ public void sampleOperation1(); /** * 这是源类Adapteee没有的方法 */ public void sampleOperation2(); &#125; 123public class Adaptee &#123; public void sampleOperation1()&#123;&#125;&#125; 12345678910public class Adapter extends Adaptee implements Target &#123; /** * 由于源类Adaptee没有方法sampleOperation2() * 因此适配器补充上这个方法 */ @Override public void sampleOperation2() &#123; //写相关的代码 &#125;&#125; 对象适配器模式： 1234567891011121314public interface Target &#123; /** * 这是源类Adaptee也有的方法 */ public void sampleOperation1(); /** * 这是源类Adapteee没有的方法 */ public void sampleOperation2(); &#125;public class Adaptee &#123; public void sampleOperation1()&#123;&#125;&#125; 适配器： 1234567891011121314151617181920public class Adapter &#123; private Adaptee adaptee; public Adapter(Adaptee adaptee)&#123; this.adaptee = adaptee; &#125; /** * 源类Adaptee有方法sampleOperation1 * 因此适配器类直接委派即可 */ public void sampleOperation1()&#123; this.adaptee.sampleOperation1(); &#125; /** * 源类Adaptee没有方法sampleOperation2 * 因此由适配器类需要补充此方法 */ public void sampleOperation2()&#123; //写相关的代码 &#125;&#125; 类适配器和对象适配器的权衡 类适配器使用对象继承的方式，是静态的定义方式；而对象适配器使用对象组合的方式，是动态组合的方式。 对于类适配器由于适配器直接继承了Adaptee，使得适配器不能和Adaptee的子类一起工作，因为继承是静态的关系，当适配器继承了Adaptee后，就不可能再去处理 Adaptee的子类了。 对于对象适配器一个适配器可以把多种不同的源适配到同一个目标。换言之，同一个适配器可以把源类和它的子类都适配到目标接口。因为对象适配器采用的是对象组合的关系，只要对象类型正确，是不是子类都无所谓。 对于类适配器适配器可以重定义Adaptee的部分行为，相当于子类覆盖父类的部分实现方法。 对于对象适配器要重定义Adaptee的行为比较困难，这种情况下，需要定义Adaptee的子类来实现重定义，然后让适配器组合子类。虽然重定义Adaptee的行为比较困难，但是想要增加一些新的行为则方便的很，而且新增加的行为可同时适用于所有的源。 对于类适配器，仅仅引入了一个对象，并不需要额外的引用来间接得到Adaptee。 对于对象适配器，需要额外的引用来间接得到Adaptee。 建议尽量使用对象适配器的实现方式，多用合成或聚合、少用继承。当然，具体问题具体分析，根据需要来选用实现方式，最适合的才是最好的。 适配器模式的优点 更好的复用性：系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。 更好的扩展性：在实现适配器功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能。 适配器模式的缺点 过多的使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 6、代理模式为其他对象提供一种代理以控制对这个对象的访问。也可以说，在出发点到目的地之间有一道中间层，意为代理。 为什么要使用 授权机制不同级别的用户对同一对象拥有不同的访问权利，如在论坛系统中，就使用Proxy进行授权机制控制，访问论坛有两种人：注册用户和游客(未注册用户)，论坛就通过类似ForumProxy这样的代理来控制这两种用户对论坛的访问权限。 某个客户端不能直接操作到某个对象，但又必须和那个对象有所互动。 举例两个具体情况： 如果那个对象是一个是很大的图片，需要花费很长时间才能显示出来，那么当这个图片包含在文档中时，使用编辑器或浏览器打开这个文档，打开文档必须很迅速，不能等待大图片处理完成，这时需要做个图片Proxy来代替真正的图片。 如果那个对象在Internet的某个远端服务器上，直接操作这个对象因为网络速度原因可能比较慢，那我们可以先用Proxy来代替那个对象。 总之原则是，对于开销很大的对象，只有在使用它时才创建，这个原则可以为我们节省很多宝贵的Java内存。所以，有些人认为Java耗费资源内存，我以为这和程序编制思路也有一定的关系。 流程图 7、装饰模式基本概念：装饰模式(Decorator)，动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。 上图是Decorator 模式的结构图,让我们可以进行更方便的描述: Component是定义一个对象接口，可以给这些对象动态地添加职责。 ConcreteComponent是定义了一个具体的对象，也可以给这个对象添加一些职责。 Decorator是装饰抽象类，继承了Component,从外类来扩展Component类的功能，但对于Component来说，是无需知道Decorator存在的。ConcreteDecorator就是具体的装饰对象，起到给Component添加职责的功能。 总结 Decorator模式有以下的优缺点： 比静态继承更灵活与对象的静态继承相比，Decorator模式提供了更加灵活的向对象添加职责的方式，可以使用添加和分离的方法，用装饰在运行时刻增加和删除职责。使用继承机制增加职责需要创建一个新的子类，如果需要为原来所有的子类都添加功能的话，每个子类都需要重写，增加系统的复杂度，此外可以为一个特定的Component类提供多个Decorator，这种混合匹配是适用继承很难做到的。 避免在层次结构高层的类有太多的特征，Decorator模式提供了一种“即用即付”的方法来添加职责，他并不试图在一个复杂的可订制的类中支持所有可预见的特征，相反可以定义一个简单的类，并且用Decorator类给他逐渐的添加功能，从简单的部件组合出复杂的功能。 Decorator 与它的Component不一样Decorator是一个透明的包装，如果我们从对象标识的观点出发，一个被装饰了的组件与这个组件是有差别的，因此使用装饰时不应该以来对象标识。 产生许多小对象，采用Decorator模式进行系统设计往往会产生许多看上去类似的小对象，这些对象仅仅在他们相互连接的方式上有所不同。","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://ccmuyu.github.io/tags/设计模式/"}]},{"title":"博客项目构建","date":"2019-05-20T13:42:18.000Z","path":"2019/05/20/first-article/","text":"忙活了一下午，终于使用 hexo cli 成功构建了第一个blog。记录下过程：第一步：环境依赖node.js npm包管理工具 hexo 主要是hexo的安装： 1$ npm install -g hexo-cli 第二步：项目初始化1$ hexo init 到到这一步，已经完成了环境的基本配置。其他使用只需要了解这几个命令就可以了。hexo new/n &quot;page name&quot; //新建文章 hexo generate/g //页面生成 hexo server/s //本地服务启动预览，localhost:4000 hexo deploy/d //上传到服务器（git等等） deploy配置的配置信息在_config.yml 中deploy 如果deploy git报错，安装deployer即可 1$ npm install hexo-deployer-git--save","categories":[],"tags":[{"name":"博客项目构建","slug":"博客项目构建","permalink":"https://ccmuyu.github.io/tags/博客项目构建/"}]},{"title":"Hello World","date":"2019-05-20T13:42:18.000Z","path":"2019/05/20/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"hello world","slug":"hello-world","permalink":"https://ccmuyu.github.io/tags/hello-world/"},{"name":"github","slug":"github","permalink":"https://ccmuyu.github.io/tags/github/"},{"name":"demo","slug":"demo","permalink":"https://ccmuyu.github.io/tags/demo/"}]}]