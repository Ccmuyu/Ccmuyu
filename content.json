[{"title":"JDK源码精读(二)","date":"2019-05-27T13:42:18.000Z","path":"2019/05/27/JDK源码精读系列（二）/","text":"JDK源码精读系列（二）","categories":[],"tags":[{"name":"JDK源码精读","slug":"JDK源码精读","permalink":"http://yoursite.com/tags/JDK源码精读/"}]},{"title":"JDK源码精读(一)","date":"2019-05-27T13:42:18.000Z","path":"2019/05/27/JDK源码精读系列（一）/","text":"JDK精读系列（一）最近有点焦躁，可能是大环境所影响，对未来有点焦虑，不想在未来的浪潮里被淘汰。 从毕业到现在工作了几年，虽然接触的知识及其广泛，变成语言从静态语言java到jvm上的groovy、Kotlin，甚至golang，到流行的动态语言python、javascript都有一定涉猎。从前端vue到数据库mysql、redis等有也用的比较多。可是进来却感觉一阵迷茫，不知道自己的核心竞争力是什么。痛定思痛，从项目中用的最多，却最不起眼的jdk开始从头再来。 首先需要认识下jdk中的3个包rt.jar、tools.jar和dt.jar dt.jar和tools.jar位于：{Java_Home}/lib/下，而rt.jar位于：{Java_Home}/jre/lib/下,其中：dt.jar是关于运行环境的类库; tools.jar是工具类库,编译和运行需要的都是toos.jar里面的类分别是sun.tools.java.; sun.tols.javac.; 在Classpath设置这几个变量，是为了方便在程序中 import；Web系统都用到tool.jar。 rt.jar rt.jar 默认就在Root Classloader的加载路径里面的，而在Claspath配置该变量是不需要的；同时jre/lib目录下的 其他jar:jce.jar、jsse.jar、charsets.jar、resources.jar都在Root Classloader中 tools.jar tools.jar 是系统用来编译一个类的时候用到的，即执行javac的时候用到 javac XXX.java 实际上就是运行 java -classpath=%JAVA_HOME%\\lib\\tools.jar xx.xxx.Main XXX.java javac就是对上面命令的封装 所以tools.jar 也不用加到classpath里面 dt.jar dt.jar是关于运行环境的类库,主要是swing的包 在用到swing时最好加上。 也即是： rt.jar：Java基础类库，也就是Java doc里面看到的所有的类的class文件。 tools.jar：是系统用来编译一个类的时候用到的，即执行javac的时候用到。 dt.jar：dt.jar是关于运行环境的类库，主要是swing包。 2、rt.jar从上面几个包的介绍来看，跟我们平常开发关系最紧密的就是rd.jar了，下图是在idea下的rt.jar com包没什么可说的，是oracle和sun公司的两个子包，openJDK是不包含着部分的，跟我们这些coder来说，息息相关的就是java包和javax包了，由于javax的使用不是很常见，本文只讨论java包。 3、java包解析以上图为切入点，applet和awt就不必说了，这是做桌面小程序所用到的，现在java的优势在于服务端的应用，我们从beans包开始。 beans包： 从java doc里的描述来看， BeanContext充当javabean的逻辑层次容器。BeanContext提供与 bean 上下文有关的类和接口。 详细描述可以参考java api：http://jszx-jxpt.cuit.edu.cn/JavaAPI/java/beans/beancontext/package-use.html/ 这个包下所有的类和接口基本都是围绕javabean和反射的。 举个简单的例子： 如果我们想获取一个类的私有变量，肯定都知道用反射，也通常都会这样： 1234567Object o = new InternetAddress(); //第一种 Class&lt;?&gt; aClass = o.getClass(); Field[] fields = aClass.getDeclaredFields(); for (Field field : fields) &#123; field.setAccessible(true); &#125; 但是这样直接修改访问权限就违背了java封装的初衷了，也有一定的安全隐患。这个时候换下面这种方式看起来就舒服多了。并且在一定程度上解决了安全问题，很多框架也渐渐在采用这种方式来进行反射的调用。 12345678BeanInfo beanInfo = Introspector.getBeanInfo(InternetAddress.class); PropertyDescriptor[] descriptors = beanInfo.getPropertyDescriptors(); for (PropertyDescriptor descriptor : descriptors) &#123; Method readMethod = descriptor.getReadMethod(); Method writeMethod = descriptor.getWriteMethod(); Object value = readMethod.invoke(o); writeMethod.invoke(o, 1); &#125; IO包io是各个编程语言的核心之一，很多程序的吞吐和性能瓶颈就在于io这块，java的io体系更是及其繁杂。简单来说，可以分为输入I/输出O两部分，从两个基类InputStream、OutputStream。基于字符的Writer和Reader，基于磁盘的File，基于网络的Socket（不在java.io包下）都要基于上面两个基类。 引用网上的一张图： https://blog.csdn.net/zhangerqing/article/details/8466532/ 上一些代码来辅助使用说明： 附上最常用的IO操作 12345678910public static String read(String filename) throws Exception &#123; BufferedReader br = new BufferedReader(new FileReader(filename)); String s; StringBuffer sb = new StringBuffer(); while ((s = br.readLine()) != null) &#123; sb.append(s + &quot;\\n&quot;); &#125; br.close(); return sb.toString(); &#125; 好了，今天就到这里。明天继续！","categories":[],"tags":[{"name":"JDK源码精读","slug":"JDK源码精读","permalink":"http://yoursite.com/tags/JDK源码精读/"}]},{"title":"dubbo源码精读","date":"2019-05-27T13:42:18.000Z","path":"2019/05/27/dubbo源码精读（一）/","text":"dubbo源码精读（一）dubbo作为java rpc框架中的一员，重要性就不多说了，每次出去跟人交流也总提到这个，虽然项目中一直在用，可却从来没完整的、系统的学习过dubbo。今天开始迈出dubbo第一步： 关于dubbo的额接本概念解释这里不做过多介绍，可以参考这篇博文,从架构层面理解dubbo: dubbo的底层原理：https://blog.csdn.net/qq_33101675/article/details/78701305 下图为我在项目中的dubbo2.5.3jar包目录结构 hession 包dubbo支持多种序列化方式，有dubbo、hessian、java、json、nativejava，（具体下文会介绍），hessian是dubbo默认的序列化方式。 dubbo这里是直接使用hessian的一个开源实现放到了com.alibaba包下，也即是上图中的con.caucho.hessian包。这个包中主要是io包，hessian对于数据的序列化和反序列化所有实现全部在这里。其余两个包是RSA加密相关和工具类。有兴趣可以参考下，个人认为没有必要深究 不出意外。序列化的顶级接口： 1234567891011package com.alibaba.com.caucho.hessian.io;import java.io.IOException;/** * Serializing an object. */public interface Serializer &#123; public void writeObject(Object obj, AbstractHessianOutput out) throws IOException;&#125; hessian序列化的具体实现代码在com.alibaba.com.caucho.hessian.io.Hessian2Output中。这里不在展示源码和贴图，简单来说就是将（byte[]） 数组转换为二进制数据，并写入流中。反序列化则刚好相反，将二进制数据转化字符编码，进而转化为java的数据类型。 反序列化的顶级接口： 12345678910111213141516171819202122232425package com.alibaba.com.caucho.hessian.io;import java.io.IOException;/** * Deserializing an object. */public interface Deserializer &#123; public Class getType(); public Object readObject(AbstractHessianInput in) throws IOException; public Object readList(AbstractHessianInput in, int length) throws IOException; public Object readLengthList(AbstractHessianInput in, int length) throws IOException; public Object readMap(AbstractHessianInput in) throws IOException; public Object readObject(AbstractHessianInput in, String []fieldNames) throws IOException;&#125; dubbo包到这里，才是真正dubbo的核心实现。从前面的图中可以看到，dubbo的实现主要包含这些内容： cache：本地缓存，缓存服务列表 common：资源工具类和注解等，包括io、日志、拓展类、JSON、线程池、各种工具类 config：dubbo配置的解析器，包括元注解、xml配置解析器及解析对象的定义，以下代码为xml解析的入口。 123456789101112131415161718192021222324252627282930313233343536373839404142package com.alibaba.dubbo.config.spring.schema;import org.springframework.beans.factory.xml.NamespaceHandlerSupport;import com.alibaba.dubbo.common.Version;import com.alibaba.dubbo.config.ApplicationConfig;import com.alibaba.dubbo.config.ConsumerConfig;import com.alibaba.dubbo.config.ModuleConfig;import com.alibaba.dubbo.config.MonitorConfig;import com.alibaba.dubbo.config.ProtocolConfig;import com.alibaba.dubbo.config.ProviderConfig;import com.alibaba.dubbo.config.RegistryConfig;import com.alibaba.dubbo.config.spring.AnnotationBean;import com.alibaba.dubbo.config.spring.ReferenceBean;import com.alibaba.dubbo.config.spring.ServiceBean;/** * DubboNamespaceHandler * * @author william.liangf * @export */public class DubboNamespaceHandler extends NamespaceHandlerSupport &#123; static &#123; Version.checkDuplicate(DubboNamespaceHandler.class); &#125; public void init() &#123; registerBeanDefinitionParser(&quot;application&quot;, new DubboBeanDefinitionParser(ApplicationConfig.class, true)); registerBeanDefinitionParser(&quot;module&quot;, new DubboBeanDefinitionParser(ModuleConfig.class, true)); registerBeanDefinitionParser(&quot;registry&quot;, new DubboBeanDefinitionParser(RegistryConfig.class, true)); registerBeanDefinitionParser(&quot;monitor&quot;, new DubboBeanDefinitionParser(MonitorConfig.class, true)); registerBeanDefinitionParser(&quot;provider&quot;, new DubboBeanDefinitionParser(ProviderConfig.class, true)); registerBeanDefinitionParser(&quot;consumer&quot;, new DubboBeanDefinitionParser(ConsumerConfig.class, true)); registerBeanDefinitionParser(&quot;protocol&quot;, new DubboBeanDefinitionParser(ProtocolConfig.class, true)); registerBeanDefinitionParser(&quot;service&quot;, new DubboBeanDefinitionParser(ServiceBean.class, true)); registerBeanDefinitionParser(&quot;reference&quot;, new DubboBeanDefinitionParser(ReferenceBean.class, false)); registerBeanDefinitionParser(&quot;annotation&quot;, new DubboBeanDefinitionParser(AnnotationBean.class, true)); &#125;&#125; container：对spring、log4j、logback、servlet等的支持 monitor：对provider、consumer的监控和数据统计，核心的实现在类DubboMonitor中 registry：服务的注册与发现，其中服务支持redis和zookeeper两种，如果有需要也可以自己实现注册中心，实现registryService和注册工厂即可。zk的注册实现在ZookeeperRegistry中。这也是项目中最常用的注册中心 remoting：主要提供了一些远程通信的实现，包括http、p2p、telnet。还集成了zookeeper的客户端 rpc：这是dubbo作为一个服务调用框架的核心功能。包含了对集群的处理、监听、通信协议、代理的实现、过滤器、rpc容器与调用等 今天就先到这里，后续对rpc继续写个专题。","categories":[],"tags":[]},{"title":"博客项目构建","date":"2019-05-27T13:42:18.000Z","path":"2019/05/27/first-article/","text":"忙活了一下午，终于使用 hexo cli 成功构建了第一个blog。记录下过程：第一步：环境依赖node.js npm包管理工具 hexo 主要是hexo的安装： 1$ npm install -g hexo-cli 第二步：项目初始化1$ hexo init 到到这一步，已经完成了环境的基本配置。其他使用只需要了解这几个命令就可以了。hexo new/n &quot;page name&quot; //新建文章 hexo generate/g //页面生成 hexo server/s //本地服务启动预览，localhost:4000 hexo deploy/d //上传到服务器（git等等） deploy配置的配置信息在_config.yml 中deploy 如果deploy git报错，安装deployer即可 1$ npm install hexo-deployer-git--save","categories":[],"tags":[{"name":"博客项目构建","slug":"博客项目构建","permalink":"http://yoursite.com/tags/博客项目构建/"}]},{"title":"Hello World","date":"2019-05-27T13:42:18.000Z","path":"2019/05/27/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"hello world","slug":"hello-world","permalink":"http://yoursite.com/tags/hello-world/"},{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"},{"name":"demo","slug":"demo","permalink":"http://yoursite.com/tags/demo/"}]},{"title":"Java中的设计模式实践","date":"2019-05-27T13:42:18.000Z","path":"2019/05/27/java中最常用的几种设计模式/","text":"Java中最常用的几种设计模式1、单例模式常见写法：懒汉式、饿汉式、静态代码块、静态内部类、枚举等。推荐采用后3种。 12345678910111213141516//懒汉式public class Singleton &#123; /* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */ private static Singleton instance = null; /* 私有构造方法，防止被实例化 */ private Singleton() &#123;&#125; /* 1:懒汉式，静态工程方法，创建实例 */ public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 1234567891011121314151617181920212223//静态内部类，推荐使用public class SingletonInner &#123; /** * 内部类实现单例模式 * 延迟加载，减少内存开销 */ private static class SingletonHolder &#123; private static SingletonInner instance = new SingletonInner(); &#125; /** * 私有的构造函数 */ private SingletonInner() &#123;&#125; public static SingletonInner getInstance() &#123; return SingletonHolder.instance; &#125; protected void method() &#123; System.out.println(&quot;SingletonInner&quot;); &#125; &#125; 其他模式不再赘述。 2、工厂模式 简单工厂模式 Simple Factory（静态工厂）：不利于长生系列产品 工厂方式模式 Facatory Method : 多形性工厂 抽象工厂模式 Abstract Factory：又称为工具箱，产生产品族，但不利于产生新的产品 静态工厂12345678public class Factory&#123; //getClass 产生Sample 一般可使用动态类装载装入类。 public static Sample creator(int which)&#123; if (which==1) return new SampleA(); else if (which==2) return new SampleB(); &#125;&#125; 目前比较流行的规范是把静态工厂方法命名为valueOf或者getInstance 12Integer a=Integer.valueOf(100); //返回取值为100的Integer对象Calendar cal=Calendar.getInstance(Locale.CHINA); //返回符合中国标准的日历 工厂方法模式工厂方法模式是简单工厂模式的进一步抽象化和推广，工厂方法模式里不再只由一个工厂类决定那一个产品类应当被实例化,这个决定被交给抽象工厂的子类去做。来看下它的组成： 抽象工厂角色： 这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在java中它由抽象类或者接口来实现。 具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象 抽象产品角色：它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现。 具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现。 工厂方法模式使用继承自抽象工厂角色的多个子类来代替简单工厂模式中的“上帝类”。正如上面所说，这样便分担了对象承受的压力；而且这样使得结构变得灵活 起来——当有新的产品（即暴发户的汽车）产生时，只要按照抽象产品角色、抽象工厂角色提供的合同来生成，那么就可以被客户使用，而不必去修改任何已有的代 码。可以看出工厂角色的结构也是符合开闭原则的！ 12345678910111213141516171819202122232425262728293031323334353637383940414243//抽象产品角色public interface Moveable &#123; void run();&#125;//具体产品角色public class Plane implements Moveable &#123; @Override public void run() &#123; System.out.println(&quot;plane....&quot;); &#125;&#125;//具体产品角色public class Broom implements Moveable &#123; @Override public void run() &#123; System.out.println(&quot;broom.....&quot;); &#125;&#125;//抽象工厂public abstract class VehicleFactory &#123; abstract Moveable create();&#125;//具体工厂public class PlaneFactory extends VehicleFactory&#123; public Moveable create() &#123; return new Plane(); &#125;&#125;//具体工厂public class BroomFactory extends VehicleFactory&#123; public Moveable create() &#123; return new Broom(); &#125;&#125;//测试类public class Test &#123; public static void main(String[] args) &#123; VehicleFactory factory = new BroomFactory(); Moveable m = factory.create(); m.run(); &#125;&#125; 简单工厂和工厂方法模式的比较 工厂方法模式和简单工厂模式在定义上的不同是很明显的。工厂方法模式的核心是一个抽象工厂类,而不像简单工厂模式, 把核心放在一个实类上。工厂方法模式可以允许很多实的工厂类从抽象工厂类继承下来, 从而可以在实际上成为多个简单工厂模式的综合,从而推广了简单工厂模式。反过来讲,简单工厂模式是由工厂方法模式退化而来。设想如果我们非常确定一个系统只需要一个实的工厂类, 那么就不妨把抽象工厂类合并到实的工厂类中去。而这样一来,我们就退化到简单工厂模式了。 抽象工厂模式 123456789101112131415161718192021222324252627282930313233//抽象工厂类public abstract class AbstractFactory &#123; public abstract Vehicle createVehicle(); public abstract Weapon createWeapon(); public abstract Food createFood();&#125;//具体工厂类，其中Food,Vehicle，Weapon是抽象类，public class DefaultFactory extends AbstractFactory&#123; @Override public Food createFood() &#123; return new Apple(); &#125; @Override public Vehicle createVehicle() &#123; return new Car(); &#125; @Override public Weapon createWeapon() &#123; return new AK47(); &#125;&#125;//测试类public class Test &#123; public static void main(String[] args) &#123; AbstractFactory f = new DefaultFactory(); Vehicle v = f.createVehicle(); v.run(); Weapon w = f.createWeapon(); w.shoot(); Food a = f.createFood(); a.printName(); &#125;&#125; 在抽象工厂模式中，抽象产品 (AbstractProduct) 可能是一个或多个，从而构成一个或多个产品族(Product Family)。 在只有一个产品族的情况下，抽象工厂模式实际上退化到工厂方法模式。 总结 简单工厂模式是由一个具体的类去创建其他类的实例，父类是相同的，父类是具体的。 工厂方法模式是有一个抽象的父类定义公共接口，子类负责生成具体的对象，这样做的目的是将类的实例化操作延迟到子类中完成。 抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无须指定他们具体的类。它针对的是有多个产品的等级结构。而工厂方法模式针对的是一个产品的等级结构。 3、建造者模式（builder）基本概念：是一种对象构建的设计模式，它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。 Builder模式是一步一步创建一个复杂的对象，它允许用户可以只通过指定复杂对象的类型和内容就可以构建它们。用户不知道内部的具体构建细节。Builder模式是非常类似抽象工厂模式，细微的区别大概只有在反复使用中才能体会到。 swagger中一个对builder的经典运用： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class ModelBuilder &#123; private String id; private String name; private String qualifiedType; private String description; private String baseModel; private String discriminator; private ResolvedType modelType; private String example; private Map&lt;String, ModelProperty&gt; properties = Maps.newHashMap(); private List&lt;String&gt; subTypes = Lists.newArrayList(); public ModelBuilder() &#123; &#125; public ModelBuilder id(String id) &#123; this.id = (String)BuilderDefaults.defaultIfAbsent(id, this.id); return this; &#125; public ModelBuilder name(String name) &#123; this.name = (String)BuilderDefaults.defaultIfAbsent(name, this.name); return this; &#125; public ModelBuilder qualifiedType(String qualifiedType) &#123; this.qualifiedType = (String)BuilderDefaults.defaultIfAbsent(qualifiedType, this.qualifiedType); return this; &#125; public ModelBuilder properties(Map&lt;String, ModelProperty&gt; properties) &#123; this.properties.putAll(BuilderDefaults.nullToEmptyMap(properties)); return this; &#125; public ModelBuilder description(String description) &#123; this.description = (String)BuilderDefaults.defaultIfAbsent(description, this.description); return this; &#125; public ModelBuilder baseModel(String baseModel) &#123; this.baseModel = (String)BuilderDefaults.defaultIfAbsent(baseModel, this.baseModel); return this; &#125; public ModelBuilder discriminator(String discriminator) &#123; this.discriminator = (String)BuilderDefaults.defaultIfAbsent(discriminator, this.discriminator); return this; &#125; public ModelBuilder subTypes(List&lt;String&gt; subTypes) &#123; if (subTypes != null) &#123; this.subTypes.addAll(subTypes); &#125; return this; &#125; public ModelBuilder example(String example) &#123; this.example = (String)BuilderDefaults.defaultIfAbsent(example, this.example); return this; &#125; public ModelBuilder type(ResolvedType modelType) &#123; this.modelType = (ResolvedType)BuilderDefaults.defaultIfAbsent(modelType, this.modelType); return this; &#125; public Model build() &#123; return new Model(this.id, this.name, this.modelType, this.qualifiedType, this.properties, this.description, this.baseModel, this.discriminator, this.subTypes, this.example); &#125;&#125; 4、观察者模式观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。观察者模式又叫发布-订阅(Publish/Subscribe)模式。 Subject类：它把所有对观察者对象的引用保存在一个聚集里，每个主题都可以有任何数量的观察着。抽象主题提供一个接口，可以增加和删除观察着对象。 Observer类：抽象观察者，为所有的具体观察者定义一个接口，在得到主题的通知时更新自己。 ConcreteSubject类：具体主题，将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。 ConcreteObserver类：具体观察者，实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。 观察者模式何时适用？ 当一个抽象模型有两个方面，其中一个方面依赖于另一方面。将这二者封装在独立的对象中可以使他们各自独立地改变和复用。 当对一个对象的改变需要同时改变其它对象，而不知道具体由多少对象有待改变。 当一个对象必须通知其他对象，而它又不能假定其他对象是谁，换言之，你不希望这些对象是紧密耦合的。让耦合的双方都依赖于抽象，而不是依赖于具体。 具体的代码就不贴了，spring中的ApplicationListener 和ApplicationEvent 就是典型的观察者模式的应用。 123456789public interface ApplicationListener&lt;E extends ApplicationEvent&gt; extends EventListener &#123; /** * Handle an application event. * @param event the event to respond to */ void onApplicationEvent(E event);&#125; 5、适配器模式（Adapter）适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。 适配器模式的结构适配器模式有类的适配器模式和对象的适配器模式两种不同的形式。 类适配器： 12345678910public interface Target &#123; /** * 这是源类Adaptee也有的方法 */ public void sampleOperation1(); /** * 这是源类Adapteee没有的方法 */ public void sampleOperation2(); &#125; 123public class Adaptee &#123; public void sampleOperation1()&#123;&#125;&#125; 12345678910public class Adapter extends Adaptee implements Target &#123; /** * 由于源类Adaptee没有方法sampleOperation2() * 因此适配器补充上这个方法 */ @Override public void sampleOperation2() &#123; //写相关的代码 &#125;&#125; 对象适配器模式： 1234567891011121314public interface Target &#123; /** * 这是源类Adaptee也有的方法 */ public void sampleOperation1(); /** * 这是源类Adapteee没有的方法 */ public void sampleOperation2(); &#125;public class Adaptee &#123; public void sampleOperation1()&#123;&#125;&#125; 适配器： 1234567891011121314151617181920public class Adapter &#123; private Adaptee adaptee; public Adapter(Adaptee adaptee)&#123; this.adaptee = adaptee; &#125; /** * 源类Adaptee有方法sampleOperation1 * 因此适配器类直接委派即可 */ public void sampleOperation1()&#123; this.adaptee.sampleOperation1(); &#125; /** * 源类Adaptee没有方法sampleOperation2 * 因此由适配器类需要补充此方法 */ public void sampleOperation2()&#123; //写相关的代码 &#125;&#125; 类适配器和对象适配器的权衡 类适配器使用对象继承的方式，是静态的定义方式；而对象适配器使用对象组合的方式，是动态组合的方式。 对于类适配器由于适配器直接继承了Adaptee，使得适配器不能和Adaptee的子类一起工作，因为继承是静态的关系，当适配器继承了Adaptee后，就不可能再去处理 Adaptee的子类了。 对于对象适配器一个适配器可以把多种不同的源适配到同一个目标。换言之，同一个适配器可以把源类和它的子类都适配到目标接口。因为对象适配器采用的是对象组合的关系，只要对象类型正确，是不是子类都无所谓。 对于类适配器适配器可以重定义Adaptee的部分行为，相当于子类覆盖父类的部分实现方法。 对于对象适配器要重定义Adaptee的行为比较困难，这种情况下，需要定义Adaptee的子类来实现重定义，然后让适配器组合子类。虽然重定义Adaptee的行为比较困难，但是想要增加一些新的行为则方便的很，而且新增加的行为可同时适用于所有的源。 对于类适配器，仅仅引入了一个对象，并不需要额外的引用来间接得到Adaptee。 对于对象适配器，需要额外的引用来间接得到Adaptee。 建议尽量使用对象适配器的实现方式，多用合成或聚合、少用继承。当然，具体问题具体分析，根据需要来选用实现方式，最适合的才是最好的。 适配器模式的优点 更好的复用性：系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。 更好的扩展性：在实现适配器功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能。 适配器模式的缺点 过多的使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 6、代理模式为其他对象提供一种代理以控制对这个对象的访问。也可以说，在出发点到目的地之间有一道中间层，意为代理。 为什么要使用 授权机制不同级别的用户对同一对象拥有不同的访问权利，如在论坛系统中，就使用Proxy进行授权机制控制，访问论坛有两种人：注册用户和游客(未注册用户)，论坛就通过类似ForumProxy这样的代理来控制这两种用户对论坛的访问权限。 某个客户端不能直接操作到某个对象，但又必须和那个对象有所互动。 举例两个具体情况： 如果那个对象是一个是很大的图片，需要花费很长时间才能显示出来，那么当这个图片包含在文档中时，使用编辑器或浏览器打开这个文档，打开文档必须很迅速，不能等待大图片处理完成，这时需要做个图片Proxy来代替真正的图片。 如果那个对象在Internet的某个远端服务器上，直接操作这个对象因为网络速度原因可能比较慢，那我们可以先用Proxy来代替那个对象。 总之原则是，对于开销很大的对象，只有在使用它时才创建，这个原则可以为我们节省很多宝贵的Java内存。所以，有些人认为Java耗费资源内存，我以为这和程序编制思路也有一定的关系。 流程图 7、装饰模式基本概念：装饰模式(Decorator)，动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。 上图是Decorator 模式的结构图,让我们可以进行更方便的描述: Component是定义一个对象接口，可以给这些对象动态地添加职责。 ConcreteComponent是定义了一个具体的对象，也可以给这个对象添加一些职责。 Decorator是装饰抽象类，继承了Component,从外类来扩展Component类的功能，但对于Component来说，是无需知道Decorator存在的。ConcreteDecorator就是具体的装饰对象，起到给Component添加职责的功能。 总结 Decorator模式有以下的优缺点： 比静态继承更灵活与对象的静态继承相比，Decorator模式提供了更加灵活的向对象添加职责的方式，可以使用添加和分离的方法，用装饰在运行时刻增加和删除职责。使用继承机制增加职责需要创建一个新的子类，如果需要为原来所有的子类都添加功能的话，每个子类都需要重写，增加系统的复杂度，此外可以为一个特定的Component类提供多个Decorator，这种混合匹配是适用继承很难做到的。 避免在层次结构高层的类有太多的特征，Decorator模式提供了一种“即用即付”的方法来添加职责，他并不试图在一个复杂的可订制的类中支持所有可预见的特征，相反可以定义一个简单的类，并且用Decorator类给他逐渐的添加功能，从简单的部件组合出复杂的功能。 Decorator 与它的Component不一样Decorator是一个透明的包装，如果我们从对象标识的观点出发，一个被装饰了的组件与这个组件是有差别的，因此使用装饰时不应该以来对象标识。 产生许多小对象，采用Decorator模式进行系统设计往往会产生许多看上去类似的小对象，这些对象仅仅在他们相互连接的方式上有所不同。","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]}]